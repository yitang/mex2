{
    "contents" : "## main funciton 1\n## estimate extreme dependence parameter alpha and beta\n## calcualte the residual matrix Z\nmex2 <- function(dt, dqu = 0.995){\n    dt.laplace2 <- dt[, lapply(.SD, toLaplace)]\n    y.cond <- dt.laplace2[[1]]\n    y.cond.th <- quantile(y.cond, dqu)\n    ind <- y.cond >= y.cond.th\n    y.cond <- y.cond[ind]\n    dt.laplace2 <- dt.laplace2[ind, ]\n    dt.dep2 <- dt.laplace2[, lapply(.SD, function(x)\n                                    my.qfun(y.cond, x)), .SDcols = -1]\n    tmp <- rbind(dt.dep2[1:4, ], dt.laplace2[, -1, with = F])\n    z.mat <- tmp[, lapply(.SD, function(x)\n                          getZMatrix(y.cond = y.cond, x[-c(1:4)], para = x[1:4]))]\n    ## format output\n    coef <- data.table(id = names(dt.dep2), t(dt.dep2[1:2, ]))\n    setnames(coef, names(coef)[2:3], c(\"a\", \"b\"))\n    HT.model <- list(coef = coef,\n                     z = z.mat, y = dt.laplace2, y.threshold = y.cond.th)\n    return(HT.model)\n}\n\n## main function 2\n## diagnosis plots\ndiag.mex <- function(HT.model){\n    ## cast\n    y.big <- HT.model$y\n    coef <- HT.model$coef\n    z <- HT.model$z\n    ## residual pltos\n    y0 <- y.big[[1]]\n    zz <- melt(z, variable.name = \"id\", value.name = \"z\", variable.factor = F)\n    zz[, y0 := y0]\n    p0 <- ggplot() + geom_point(data = zz, aes(y0, z)) + facet_wrap(~id)\n    ## condifdence interval plot\n    yy <- melt(y.big[, -1, with=F], variable.name = \"id\", value.name = \"y\", variable.factor = F)\n    yy[, y0 := y0]\n    band <- copy(zz)\n    band[, lower := quantile(z, 0.025), by = id]\n    band[, upper := quantile(z, 0.975), by = id]\n    setkey(band, id)\n    band <- unique(band)\n    band <- merge(coef, band, by = \"id\")[, list(id, a, b, lower, upper)]\n    y.seq <- seq(min(y0), max(y0), len = 1e3)\n    band2 <- band[, list(y.seq,\n                         lower = lower * y.seq^b + y.seq * a,\n                         upper = upper * y.seq^b + y.seq * a),\n                  by = id]\n    p1 <- ggplot() + geom_point(data = yy, aes(y0, y)) + geom_ribbon(data = band2, aes(y.seq, ymin = lower, ymax = upper), alpha = 0.2) + facet_wrap(~id)\n    return(list(p0, p1))\n}\n\n\n## main funciton 3\n## simulate\nsamp.cond <- function(HT.model){\n    ## cast\n    z <- HT.model$z\n    alpha <- HT.model$coef$a\n    beta <- HT.model$coef$b\n    y0 <- HT.model$y.threshold\n    ## simulate\n    alpha <- y0*alpha\n    beta <- y0^beta\n    tmp <- as.data.table(rbind(rbind(alpha,beta), z))\n    sim <- tmp[, lapply(.SD, function(x)\n                        x[-c(1:2)] * x[2] + x[1])]\n    sim <- data.table(y0 = y0, sim)\n    return(sim)\n}\n\n\n\n## tranfer x to laplapce distribution, using expiral distirbution\ntoLaplace <- function(x, mu = 0, b = 1){\n    ## u <- rank(x, ties = \"random\") / (1+length(x))\n    u <- rank(x) / (1+length(x))\n    y <-     mu - b * sign(u - 0.5) * log(1 - 2 * abs(u - 0.5))\n    return(y)\n}\n\n## laplace distirbution functions\nqLaplace <- function(p, mu = 0, b = 1){\n     ## mu is locaton param, b is scale para\n    mu - b * sign(p - 0.5) * log(1 - 2 * abs(p - 0.5))\n}\npLaplace <- function(x, mu = 0, b = 1){\n    ## mu is location para, b is scale para\n    1/2 + 1/2 * sign(x - mu) * (1  - exp(- abs(x - mu) / b))\n}\n\n## tranfrom laplace (y) to x distributiuon, using GPD extrpolate\ny2x <- function(y, x, qu, coef){\n    u <- pLaplace(y)\n    xx <- rep(NA, len = length(u))\n    threshold <- quantile(x, qu)\n    ind <- u <= qu\n    xx[ind] <- quantile(x, u[ind])\n    if (any(!ind )){\n        sig <- coef[2]\n        xi <- coef[3]\n        xx[!ind] <- texmex::qgpd(1- (1 - u[!ind]) / (1 - qu), sigma = sig, xi = xi, u = 0) + threshold\n    }\n    return(xx)\n}\n\n## calcualte Z matrix\ngetZMatrix <- function(y.cond, x, para){\n    a <- para[1]\n    b <- para[2]\n    cee <- para[3]\n    d <- para[4]\n    if (is.na(a))\n        rep(NA, length(x)) else {\n            if (a < 10^(-5) & b < 0)\n                a <- cee - d * log(y.cond) else a <- a * y.cond\n            (x - a)/(y.cond^b)\n        }\n}\n\n\n\n########### the folloiwng fnctions are copied from texemx pacgage ###\n## a wrapper for NLH optimisation\n## returns dependnecne parameters(alpha, beta) and likelihood\nmy.qfun <- function(y.cond, y.dep, aLow = -1 + 10^(-10), margins = \"laplace\", constrain = FALSE, v = 10, maxit = 10000, start = c(0.01, 0.01) , nOptim = 1) {\n    o <- try(optim(par = start, fn = Qpos, control = list(maxit = maxit), yex = y.cond, ydep = y.dep, constrain = constrain, v = v, aLow = aLow), silent = FALSE)\n    ## optim catch block.\n    if (class(o) == \"try-error\") {\n        warning(\"Error in optim call from mexDependence\")\n        o <- as.list(o)\n        o$par <- rep(NA, 6)\n        o$value <- NA\n    } else if (o$convergence != 0) {\n        warning(\"Non-convergence in mexDependence\")\n        o <- as.list(o)\n        o$par <- rep(NA, 6)\n    } else if (nOptim > 1) { ## run optim k time.s\n        for (i in 2:nOptim) {\n            o <- try(optim(par = o$par, fn = Qpos, control = list(maxit = maxit), yex = y.cond, ydep = y.dep, constrain = constrain, v = v,\n                           aLow = aLow), silent = TRUE)\n            if (class(o) == \"try-error\") {\n                warning(\"Error in optim call from mexDependence\")\n                o <- as.list(o)\n                o$par <- rep(NA, 6)\n                o$value <- NA\n                (break)()\n            } else if (o$convergence != 0) {\n                warning(\"Non-convergence in mexDependence\")\n                o <- as.list(o)\n                o$par <- rep(NA, 6)\n                (break)()\n            }\n        }\n    }\n    ## gumbel margins and negative dependence\n    if (!is.na(o$par[1])) {\n                                        # gumbel margins and negative dependence\n        if (margins == \"gumbel\" & o$par[1] <= 10^(-5) & o$par[2] < 0) {\n            lo <- c(10^(-10), -Inf, -Inf, 10^(-10), -Inf, 10^(-10))\n            Qneg <- function(yex, ydep, param) {\n                param <- param[-1]\n                b <- param[1]\n                cee <- param[2]\n                d <- param[3]\n                m <- param[4]\n                s <- param[5]\n                obj <- function(yex, ydep, b, cee, d, m, s) {\n                    mu <- cee - d * log(yex) + m * yex^b\n                    sig <- s * yex^b\n                    log(sig) + 0.5 * ((ydep - mu)/sig)^2\n                }\n                res <- sum(obj(yex, ydep, b, cee, d, m, s))\n                res\n            }\n            o <- try(optim(c(0, 0, 0, 0, 0, 1), Qneg, method = \"L-BFGS-B\", lower = lo, upper = c(1, 1 - 10^(-10), Inf, 1 - 10^(-10), Inf, Inf),\n                           yex = y.cond, ydep = y.dep), silent = TRUE)\n            if (class(o) == \"try-error\" || o$convergence != 0) {\n                warning(\"Non-convergence in mexDependence\")\n                o <- as.list(o)\n                o$par <- rep(NA, 6)\n            }\n        } else {\n                                        # end if gumbel margins and neg dependence\n            Z <- (y.dep - y.cond * o$par[1])/(y.cond^o$par[2])\n            o$par <- c(o$par[1:2], 0, 0, mean(Z), sd(Z))\n        }\n    }\n    return(c(o$par[1:6], o$value))  # Parameters and negative loglik\n}  # Close qfun <- function(\n\n## a wrapper for lower level functions.\n## return negative log likeliihohod\nQpos <- function(param, yex, ydep, constrain, v, aLow) {\n    a <- param[1]\n    b <- param[2]\n    res <- PosGumb.Laplace.negProfileLogLik(yex, ydep, a, b, constrain, v, aLow)  # defined in file mexDependenceLowLevelFunctions\n    res$profLik\n}\n\n\n\n                                        # check constraints on parameters under constrained Laplace estimation\nConstraintsAreSatisfied <- function(a,b,z,zpos,zneg,v){\n    C1e <- a <= min(1, 1 - b*min(z)*v^(b-1), 1 - v^(b-1)*min(z) + min(zpos)/v) &\n        a <= min(1, 1 - b*max(z)*v^(b-1), 1 - v^(b-1)*max(z) + max(zpos)/v)\n\n    C1o <- a <= 1 &\n        a > 1 - b * min(z) * v^(b-1) &\n            a > 1 - b * max(z) * v^(b-1) &\n                (1 - 1/b)*(b*min(z))^(1/(1-b)) * (1-a)^(-b/(1 - b)) + min(zpos) > 0 &\n                    (1 - 1/b)*(b*max(z))^(1/(1-b)) * (1-a)^(-b/(1 - b)) + max(zpos) > 0\n\n    C2e <- -a <= min(1, 1 + b*v^(b-1)*min(z), 1 + v^(b-1)*min(z) - min(zneg)/v) &\n        -a <= min(1, 1 + b*v^(b-1)*max(z), 1 + v^(b-1)*max(z) - max(zneg)/v)\n\n    C2o <- -a <= 1 &\n        -a > 1 + b*v^(b-1)*min(z) &\n            -a > 1 + b*v^(b-1)*max(z) &\n                (1-1/b)*(-b*min(z))^(1/(1-b))*(1+a)^(-b/(1-b)) - min(zneg) > 0 &\n                    (1-1/b)*(-b*max(z))^(1/(1-b))*(1+a)^(-b/(1-b)) - max(zneg) > 0\n\n    if (any(is.na(c(C1e, C1o, C2e, C2o)))) {\n        warning(\"Strayed into impossible area of parameter space\")\n        C1e <- C1o <- C2e <- C2o <- FALSE\n    }\n\n    (C1e | C1o) && (C2e | C2o)\n}\n\n                                        # positive dependence Gumbel and pos or neg dependence Laplace neg likelihood function\nPosGumb.Laplace.negloglik <- function(yex, ydep, a, b, m, s, constrain, v, aLow) {\n    BigNumber <- 10^40\n    WeeNumber <- 10^(-10)\n\n    if(a < aLow[1] | s < WeeNumber | a > 1-WeeNumber  | b > 1-WeeNumber) {\n        res <- BigNumber\n    } else {\n        mu <- a * yex + m * yex^b\n        sig <- s * yex^b\n\n        res <- sum(0.5 * log(2*pi) + log(sig) + 0.5 * ((ydep - mu)/sig)^2)\n\n        if (is.infinite(res)){\n            if (res < 0){\n                res <- -BigNumber\n            } else {\n                res <- BigNumber\n            }\n            warning(\"Infinite value of Q in mexDependence\")\n        } else if (constrain){\n                                        #v <- v * max(yex)\n            zpos <- range(ydep - yex) # q0 & q1\n            z <- range((ydep - yex * a) / (yex^b)) # q0 & q1\n            zneg <- range(ydep + yex) # q0 & q1\n\n            if (!ConstraintsAreSatisfied(a,b,z,zpos,zneg,v)){\n                res <- BigNumber\n            }\n        }\n    }\n    res\n}\n\nPosGumb.Laplace.negProfileLogLik <- function(yex, ydep, a, b, constrain, v, aLow) {\n    Z <- (ydep - yex * a) / (yex^b)\n\n    m <- mean(Z)\n    s <- sd(Z)\n\n    res <- PosGumb.Laplace.negloglik(yex,ydep,a,b,m=m,s=s,constrain,v,aLow=aLow)\n    res <- list(profLik=res,m=m, s=s)\n    res\n}\n",
    "created" : 1408708697894.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "203367488",
    "id" : "CDE1AE97",
    "lastKnownWriteTime" : 1409156921,
    "path" : "C:/vmshare/texmex_hack/HTModel/R/mex2.R",
    "project_path" : "R/mex2.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}